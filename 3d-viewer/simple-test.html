<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Viewer Test - NO3D TOOLS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            overflow: hidden;
            color: #fff;
        }

        /* Full viewport 3D viewer */
        #viewer-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
        }

        /* Sidebar controls panel */
        .controls-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
            transform: translateX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            padding: 20px;
        }

        .controls-panel.collapsed {
            transform: translateX(320px);
        }

        /* Toggle button */
        .toggle-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .toggle-controls:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .toggle-controls::before {
            content: '‚öô';
            font-size: 20px;
            color: #fff;
        }

        /* Panel header */
        .panel-header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-header h1 {
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: #fff;
            margin-bottom: 8px;
        }

        .panel-header p {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }

        /* Control sections */
        .control-section {
            margin-bottom: 24px;
        }

        .control-section h3 {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 12px;
        }

        /* Control items */
        .control-item {
            margin-bottom: 16px;
        }

        .control-item label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 400;
            font-family: 'Courier New', monospace;
        }

        /* Range sliders */
        input[type="range"] {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            border-radius: 1px;
            position: relative;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.1);
        }

        /* Color pickers */
        input[type="color"] {
            width: 100%;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        input[type="color"]:hover {
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Selects and inputs */
        select, input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        select:hover, input[type="text"]:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* Buttons */
        button {
            width: 100%;
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        /* Checkboxes */
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #fff;
        }

        /* File input */
        input[type="file"] {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        input[type="file"]::file-selector-button {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 11px;
        }

        input[type="file"]::file-selector-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Quick load grid */
        .quick-load {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .quick-load button {
            padding: 8px;
            font-size: 10px;
        }

        /* Status indicator */
        .status-bar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px 16px;
            font-size: 11px;
            z-index: 1000;
            max-width: 400px;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-indicator.ready {
            background: #4caf50;
        }

        .status-indicator.loading {
            background: #ffc107;
        }

        .status-indicator.error {
            background: #f44336;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Scrollbar styling */
        .controls-panel::-webkit-scrollbar {
            width: 6px;
        }

        .controls-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .controls-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .controls-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <!-- Full viewport 3D viewer -->
    <div id="viewer-container"></div>

    <!-- Toggle button -->
    <div class="toggle-controls" onclick="togglePanel()"></div>

    <!-- Status bar -->
    <div class="status-bar">
        <span class="status-indicator loading" id="status"></span>
        <span id="info">Initializing viewer...</span>
    </div>

    <!-- Sidebar controls panel -->
    <div class="controls-panel" id="controls-panel">
        <div class="panel-header">
            <h1>3D Viewer</h1>
            <p>STL / GLB / GLTF / 3MF / JSON Model Visualization</p>
        </div>

        <!-- File Selection -->
        <div class="control-section">
            <h3>Load Model</h3>
            <div class="control-item">
                <input type="file" id="file-input" accept=".stl,.glb,.gltf,.3mf,.json">
            </div>
            <div class="quick-load">
                <button onclick="loadSample('Vert_015_20250902_192454.stl')">STL Small<br>76KB</button>
                <button onclick="loadSample('Cube_005_20250808_140127.stl')">STL Med<br>1.2MB</button>
                <button onclick="loadSample('loose_snake_lighter_20251112_225345.stl')">STL Large<br>3.8MB</button>
            </div>
        </div>

        <!-- Material -->
        <div class="control-section">
            <h3>Material</h3>
            <div class="control-item">
                <label>Color</label>
                <input type="color" id="material-color" value="#888888">
            </div>
            <div class="control-item">
                <label>Metalness <span class="control-value" id="metalness-val">0.3</span></label>
                <input type="range" id="metalness" min="0" max="1" step="0.01" value="0.3">
            </div>
            <div class="control-item">
                <label>Roughness <span class="control-value" id="roughness-val">0.4</span></label>
                <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.4">
            </div>
            <div class="control-item">
                <label>
                    <span>Show Edges</span>
                    <input type="checkbox" id="show-edges" checked>
                </label>
            </div>
            <div class="control-item">
                <label>Edge Color</label>
                <input type="color" id="edge-color" value="#000000">
            </div>
            <div class="control-item">
                <label>Edge Thickness <span class="control-value"><span id="edge-thickness-val">2</span>px</span></label>
                <input type="range" id="edge-thickness" min="0.1" max="50" step="0.5" value="2">
            </div>
        </div>

        <!-- Lighting -->
        <div class="control-section">
            <h3>Lighting</h3>
            <div class="control-item">
                <label>Hemisphere <span class="control-value" id="hemi-intensity-val">0.6</span></label>
                <input type="range" id="hemi-intensity" min="0" max="2" step="0.1" value="0.6">
            </div>
            <div class="control-item">
                <label>Key Light <span class="control-value" id="key-intensity-val">0.8</span></label>
                <input type="range" id="key-intensity" min="0" max="2" step="0.1" value="0.8">
            </div>
            <div class="control-item">
                <label>Fill Light <span class="control-value" id="fill-intensity-val">0.4</span></label>
                <input type="range" id="fill-intensity" min="0" max="2" step="0.1" value="0.4">
            </div>
            <div class="control-item">
                <label>Rim Light <span class="control-value" id="rim-intensity-val">0.5</span></label>
                <input type="range" id="rim-intensity" min="0" max="2" step="0.1" value="0.5">
            </div>
            <div class="control-item">
                <label>Ambient <span class="control-value" id="ambient-intensity-val">0.2</span></label>
                <input type="range" id="ambient-intensity" min="0" max="2" step="0.1" value="0.2">
            </div>
        </div>

        <!-- Background -->
        <div class="control-section">
            <h3>Background</h3>
            <div class="control-item">
                <label>Mode</label>
                <select id="bg-mode">
                    <option value="transparent">Transparent</option>
                    <option value="color">Solid Color</option>
                </select>
            </div>
            <div class="control-item">
                <label>Color</label>
                <input type="color" id="bg-color" value="#E8E8E8" disabled>
            </div>
        </div>

        <!-- Shader Presets -->
        <div class="control-section">
            <h3>Shader Presets</h3>
            <div class="control-item">
                <label>Style</label>
                <select id="shader-preset">
                    <option value="pbr">PBR (Realistic)</option>
                    <option value="toon">Toon/Cel Shaded</option>
                    <option value="matcap">MatCap</option>
                    <option value="clay">Clay Render</option>
                    <option value="metal">Metallic</option>
                    <option value="plastic">Plastic</option>
                    <option value="glass">Glass</option>
                </select>
            </div>
            <div class="control-item">
                <label>Toon Steps <span class="control-value"><span id="toon-steps-val">4</span></span></label>
                <input type="range" id="toon-steps" min="2" max="10" step="1" value="4" disabled>
            </div>
            <div class="control-item">
                <button onclick="applyShaderPreset()">Apply Preset</button>
            </div>
        </div>

        <!-- Environment -->
        <div class="control-section">
            <h3>Environment</h3>
            <div class="control-item">
                <label>Preset</label>
                <select id="env-preset">
                    <option value="">None (Custom URL)</option>
                    <option value="studio">Studio Neutral</option>
                    <option value="outdoor">Outdoor Sky</option>
                    <option value="sunset">Sunset Warm</option>
                    <option value="night">Night Urban</option>
                    <option value="warehouse">Warehouse Industrial</option>
                </select>
            </div>
            <div class="control-item">
                <label>Custom URL</label>
                <input type="text" id="env-map-url" placeholder="https://example.com/hdri.jpg">
            </div>
            <div class="control-item">
                <label>Intensity <span class="control-value" id="env-intensity-val">1.0</span></label>
                <input type="range" id="env-intensity" min="0" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-item">
                <button onclick="loadEnvironmentMap()">Load Environment</button>
            </div>
        </div>

        <!-- Camera -->
        <div class="control-section">
            <h3>Camera</h3>
            <div class="control-item">
                <label>Model Origin</label>
                <select id="model-origin">
                    <option value="center">Center of Mesh</option>
                    <option value="bottom">Bottom of Mesh</option>
                </select>
            </div>
            <div class="control-item">
                <button onclick="recenterModel()">Re-center Model</button>
            </div>
            <div class="control-item">
                <label>Distance <span class="control-value"><span id="camera-distance-val">1.3</span>x</span></label>
                <input type="range" id="camera-distance" min="0.5" max="3" step="0.1" value="1.3">
            </div>
            <div class="control-item">
                <label>FOV <span class="control-value"><span id="fov-val">45</span>¬∞</span></label>
                <input type="range" id="fov" min="20" max="90" step="5" value="45">
            </div>
            <div class="control-item">
                <label>Rotate Speed <span class="control-value" id="rotate-speed-val">0.005</span></label>
                <input type="range" id="rotate-speed" min="0.0001" max="0.01" step="0.0001" value="0.005">
            </div>
        </div>

        <!-- Animation (GLB/GLTF) -->
        <div class="control-section" id="animation-section" style="display: none;">
            <h3>Animation</h3>
            <div class="control-item">
                <label>Animation Clip</label>
                <select id="animation-clip">
                    <option value="">No animations</option>
                </select>
            </div>
            <div class="control-item">
                <label>
                    <span>Loop Animation</span>
                    <input type="checkbox" id="animation-loop" checked>
                </label>
            </div>
            <div class="control-item">
                <label>Speed <span class="control-value"><span id="animation-speed-val">1.0</span>x</span></label>
                <input type="range" id="animation-speed" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-item">
                <button onclick="toggleAnimation()">Play/Pause</button>
            </div>
        </div>
    </div>

    <!-- THREE.js (local) -->
    <script src="libs/three.min.js"></script>

    <!-- STL Loader (local, uses global THREE) -->
    <script src="libs/STLLoader-global.js"></script>

    <!-- Import map for THREE modules -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js"
        }
    }
    </script>

    <!-- GLTF Loader from CDN -->
    <script type="module">
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
        window.GLTFLoader = GLTFLoader;
        window.gltfLoaderReady = true;
        console.log('‚úÖ GLTFLoader imported and ready');
    </script>

    <!-- 3MF Loader from CDN -->
    <script type="module">
        import { ThreeMFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/3MFLoader.js';
        window.ThreeMFLoader = ThreeMFLoader;
        window.threemfLoaderReady = true;
        console.log('‚úÖ ThreeMFLoader imported and ready');
    </script>

    <script>
        console.log('üîÑ Initializing viewer...');

        const container = document.getElementById('viewer-container');
        const statusEl = document.getElementById('status');
        const infoEl = document.getElementById('info');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = null; // Transparent background

        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 100000);
        camera.position.set(0, 2, 5);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true // Enable transparency
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        // Enhanced Studio Lighting Setup
        // Hemisphere light (sky + ground for natural ambient)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        // Key light (main light source)
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(5, 10, 7);
        keyLight.castShadow = true;
        scene.add(keyLight);

        // Fill light (softens shadows)
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // Rim light (edge definition)
        const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
        rimLight.position.set(0, 5, -10);
        scene.add(rimLight);

        // Ambient light (overall scene brightness)
        const ambient = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambient);

        let mesh = null;
        let meshGroup = null;  // Group for world-space rotation
        let edgesMesh = null;  // Edges for technical drawing look
        let rotating = true;
        let rotateSpeed = 0.005;
        let currentMaterial = null;

        // Animation variables
        let mixer = null;  // THREE.AnimationMixer
        let currentAction = null;  // Current AnimationAction
        let animations = [];  // Array of available animations
        let clock = new THREE.Clock();  // Clock for animation timing

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update animation mixer if exists
            if (mixer) {
                mixer.update(delta);
            }

            if (meshGroup && rotating) {
                // Rotate around world Y-axis (vertical)
                meshGroup.rotation.y += rotateSpeed;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        statusEl.textContent = '‚úÖ Ready';
        statusEl.className = 'status-indicator ready';
        infoEl.textContent = 'Viewer ready. Load an STL, GLB, GLTF, 3MF, or THREE.js JSON file to view it.';
        console.log('‚úÖ Viewer initialized');

        // Load STL function
        function loadSTL(url, filename) {
            statusEl.textContent = '‚è≥ Loading...';
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = `Loading ${filename}...`;

            console.log(`üìÅ Loading: ${filename}`);

            const loader = new THREE.STLLoader();

            loader.load(
                url,
                (geometry) => {
                    console.log('‚úÖ STL loaded:', {
                        vertices: geometry.attributes.position.count
                    });

                    // Remove old mesh
                    if (mesh) {
                        scene.remove(mesh);
                    }

                    // Compute normals if not present
                    if (!geometry.attributes.normal) {
                        geometry.computeVertexNormals();
                    }

                    // Remove old mesh group if exists
                    if (meshGroup) {
                        scene.remove(meshGroup);
                    }

                    // Create PBR material (MeshStandardMaterial)
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        metalness: 0.3,
                        roughness: 0.4,
                        envMapIntensity: 1.0
                    });
                    currentMaterial = material;

                    mesh = new THREE.Mesh(geometry, material);

                    // Create edges geometry for technical drawing look
                    const edgesGeometry = new THREE.EdgesGeometry(geometry, 30);
                    const edgesMaterial = new THREE.LineBasicMaterial({
                        color: 0x000000,
                        linewidth: 2
                    });
                    edgesMesh = new THREE.LineSegments(edgesGeometry, edgesMaterial);

                    // Correct for Blender's Z-up coordinate system
                    // Rotate -90 degrees around X axis to convert Z-up to Y-up
                    mesh.rotation.x = -Math.PI / 2;
                    edgesMesh.rotation.x = -Math.PI / 2;

                    // Create a group to hold both mesh and edges
                    meshGroup = new THREE.Group();
                    meshGroup.add(mesh);
                    meshGroup.add(edgesMesh);
                    scene.add(meshGroup);

                    // Center the model using shared function
                    const { size } = centerModel(meshGroup);

                    // Calculate optimal camera distance to fit object in view
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180); // Convert to radians
                    let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));

                    // Add some padding (user-adjustable via camera-distance control)
                    const distanceMultiplier = parseFloat(document.getElementById('camera-distance').value);
                    cameraDistance *= distanceMultiplier;

                    // Position camera to view object optimally
                    camera.position.set(
                        cameraDistance * 0.5,
                        cameraDistance * 0.5,
                        cameraDistance
                    );
                    camera.lookAt(0, 0, 0);

                    console.log('üìê Object centered and framed:', {
                        size: `${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`,
                        maxDim: maxDim.toFixed(2),
                        cameraDistance: cameraDistance.toFixed(2)
                    });

                    statusEl.textContent = '‚úÖ Loaded';
                    statusEl.className = 'status-indicator ready';
                    infoEl.textContent = `${filename} - ${geometry.attributes.position.count} vertices - Size: ${maxDim.toFixed(2)} units`;

                    console.log('‚úÖ Model displayed');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        infoEl.textContent = `Loading ${filename}... ${percent}%`;
                    }
                },
                (error) => {
                    console.error('‚ùå Load error:', error);
                    statusEl.textContent = '‚ùå Error';
                    statusEl.className = 'status-indicator error';
                    infoEl.textContent = `Error loading ${filename}: ${error.message}`;
                }
            );
        }

        // Load GLB/GLTF function
        function loadGLTF(url, filename) {
            if (!window.GLTFLoader) {
                console.error('‚ùå GLTFLoader not loaded yet');
                alert('GLTFLoader is still loading. Please try again in a moment.');
                return;
            }

            statusEl.textContent = '‚è≥ Loading...';
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = `Loading ${filename}...`;

            console.log(`üìÅ Loading GLTF/GLB: ${filename}`);

            const loader = new window.GLTFLoader();

            loader.load(
                url,
                (gltf) => {
                    console.log('‚úÖ GLTF loaded:', gltf);

                    // Remove old mesh group if exists
                    if (meshGroup) {
                        scene.remove(meshGroup);
                    }

                    // Create group for the GLTF scene
                    meshGroup = new THREE.Group();

                    // Add the entire GLTF scene
                    const model = gltf.scene;

                    // Apply Blender orientation correction to the entire model
                    model.rotation.x = -Math.PI / 2;

                    meshGroup.add(model);
                    scene.add(meshGroup);

                    // Center the model using shared function
                    const { size } = centerModel(meshGroup);

                    // Extract first material for controls (if available)
                    let materialFound = false;
                    model.traverse((child) => {
                        if (child.isMesh && !materialFound) {
                            currentMaterial = child.material;
                            materialFound = true;

                            // Update UI controls to match the material
                            if (currentMaterial.color) {
                                const color = '#' + currentMaterial.color.getHexString();
                                document.getElementById('material-color').value = color;
                            }
                            if (currentMaterial.metalness !== undefined) {
                                document.getElementById('metalness').value = currentMaterial.metalness;
                                document.getElementById('metalness-val').textContent = currentMaterial.metalness;
                            }
                            if (currentMaterial.roughness !== undefined) {
                                document.getElementById('roughness').value = currentMaterial.roughness;
                                document.getElementById('roughness-val').textContent = currentMaterial.roughness;
                            }
                        }
                    });

                    // Note: Edges are not created for GLTF models by default
                    // as they may have multiple meshes with different geometries
                    edgesMesh = null;
                    mesh = null;

                    // Calculate optimal camera distance
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));

                    const distanceMultiplier = parseFloat(document.getElementById('camera-distance').value);
                    cameraDistance *= distanceMultiplier;

                    camera.position.set(
                        cameraDistance * 0.5,
                        cameraDistance * 0.5,
                        cameraDistance
                    );
                    camera.lookAt(0, 0, 0);

                    console.log('üìê GLTF centered and framed:', {
                        size: `${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`,
                        maxDim: maxDim.toFixed(2),
                        cameraDistance: cameraDistance.toFixed(2)
                    });

                    // Setup animations if available
                    setupAnimations(gltf);

                    statusEl.textContent = '‚úÖ Loaded';
                    statusEl.className = 'status-indicator ready';
                    infoEl.textContent = `${filename} - GLTF model - Size: ${maxDim.toFixed(2)} units`;

                    console.log('‚úÖ GLTF model displayed');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        infoEl.textContent = `Loading ${filename}... ${percent}%`;
                    }
                },
                (error) => {
                    console.error('‚ùå GLTF load error:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        filename: filename,
                        url: url
                    });
                    statusEl.textContent = '‚ùå Error';
                    statusEl.className = 'status-indicator error';
                    infoEl.textContent = `Error loading ${filename}: ${error.message || 'Unknown error'}`;
                    alert(`Failed to load GLB/GLTF file.\n\nError: ${error.message || 'Unknown error'}\n\nCheck browser console (F12) for details.`);
                }
            );
        }

        // Load 3MF function
        function load3MF(url, filename) {
            if (!window.ThreeMFLoader) {
                console.error('‚ùå ThreeMFLoader not loaded yet');
                alert('ThreeMFLoader is still loading. Please try again in a moment.');
                return;
            }

            statusEl.textContent = '‚è≥ Loading...';
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = `Loading ${filename}...`;

            console.log(`üìÅ Loading 3MF: ${filename}`);

            const loader = new window.ThreeMFLoader();

            loader.load(
                url,
                (object) => {
                    console.log('‚úÖ 3MF loaded:', object);

                    // Remove old mesh group if exists
                    if (meshGroup) {
                        scene.remove(meshGroup);
                    }

                    // Create group for the 3MF object
                    meshGroup = new THREE.Group();

                    // 3MFLoader returns a Group or Object3D
                    const model = object;

                    meshGroup.add(model);
                    scene.add(meshGroup);

                    // Center the model using shared function
                    const { size } = centerModel(meshGroup);

                    // Extract first material for controls (if available)
                    let materialFound = false;
                    model.traverse((child) => {
                        if (child.isMesh && !materialFound) {
                            currentMaterial = child.material;
                            materialFound = true;

                            // Update UI controls to match the material
                            if (currentMaterial.color) {
                                const color = '#' + currentMaterial.color.getHexString();
                                document.getElementById('material-color').value = color;
                            }
                            if (currentMaterial.metalness !== undefined) {
                                document.getElementById('metalness').value = currentMaterial.metalness;
                                document.getElementById('metalness-val').textContent = currentMaterial.metalness;
                            }
                            if (currentMaterial.roughness !== undefined) {
                                document.getElementById('roughness').value = currentMaterial.roughness;
                                document.getElementById('roughness-val').textContent = currentMaterial.roughness;
                            }
                        }
                    });

                    // Note: Edges are not created for 3MF models by default
                    // as they may have multiple meshes with different geometries
                    edgesMesh = null;
                    mesh = null;

                    // Calculate optimal camera distance
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));

                    const distanceMultiplier = parseFloat(document.getElementById('camera-distance').value);
                    cameraDistance *= distanceMultiplier;

                    camera.position.set(
                        cameraDistance * 0.5,
                        cameraDistance * 0.5,
                        cameraDistance
                    );
                    camera.lookAt(0, 0, 0);

                    console.log('üìê 3MF centered and framed:', {
                        size: `${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`,
                        maxDim: maxDim.toFixed(2),
                        cameraDistance: cameraDistance.toFixed(2)
                    });

                    statusEl.textContent = '‚úÖ Loaded';
                    statusEl.className = 'status-indicator ready';
                    infoEl.textContent = `${filename} - 3MF model - Size: ${maxDim.toFixed(2)} units`;

                    console.log('‚úÖ 3MF model displayed');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        infoEl.textContent = `Loading ${filename}... ${percent}%`;
                    }
                },
                (error) => {
                    console.error('‚ùå 3MF load error:', error);
                    statusEl.textContent = '‚ùå Error';
                    statusEl.className = 'status-indicator error';
                    infoEl.textContent = `Error loading ${filename}: ${error.message}`;
                }
            );
        }

        // Load THREE.js JSON function
        function loadJSON(url, filename) {
            statusEl.textContent = '‚è≥ Loading...';
            statusEl.className = 'status-indicator loading';
            infoEl.textContent = `Loading ${filename}...`;

            console.log(`üìÅ Loading THREE.js JSON: ${filename}`);

            const loader = new THREE.ObjectLoader();

            loader.load(
                url,
                (object) => {
                    console.log('‚úÖ THREE.js JSON loaded:', object);

                    // Remove old mesh group if exists
                    if (meshGroup) {
                        scene.remove(meshGroup);
                    }

                    // Create group for the JSON object
                    meshGroup = new THREE.Group();

                    meshGroup.add(object);
                    scene.add(meshGroup);

                    // Center the model using shared function
                    const { size } = centerModel(meshGroup);

                    // Extract first material for controls (if available)
                    let materialFound = false;
                    object.traverse((child) => {
                        if (child.isMesh && !materialFound) {
                            currentMaterial = child.material;
                            materialFound = true;

                            // Update UI controls to match the material
                            if (currentMaterial.color) {
                                const color = '#' + currentMaterial.color.getHexString();
                                document.getElementById('material-color').value = color;
                            }
                            if (currentMaterial.metalness !== undefined) {
                                document.getElementById('metalness').value = currentMaterial.metalness;
                                document.getElementById('metalness-val').textContent = currentMaterial.metalness;
                            }
                            if (currentMaterial.roughness !== undefined) {
                                document.getElementById('roughness').value = currentMaterial.roughness;
                                document.getElementById('roughness-val').textContent = currentMaterial.roughness;
                            }
                        }
                    });

                    // Note: Edges are not created for JSON models by default
                    edgesMesh = null;
                    mesh = null;

                    // Calculate optimal camera distance
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));

                    const distanceMultiplier = parseFloat(document.getElementById('camera-distance').value);
                    cameraDistance *= distanceMultiplier;

                    camera.position.set(
                        cameraDistance * 0.5,
                        cameraDistance * 0.5,
                        cameraDistance
                    );
                    camera.lookAt(0, 0, 0);

                    console.log('üìê JSON centered and framed:', {
                        size: `${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`,
                        maxDim: maxDim.toFixed(2),
                        cameraDistance: cameraDistance.toFixed(2)
                    });

                    statusEl.textContent = '‚úÖ Loaded';
                    statusEl.className = 'status-indicator ready';
                    infoEl.textContent = `${filename} - THREE.js JSON - Size: ${maxDim.toFixed(2)} units`;

                    console.log('‚úÖ THREE.js JSON model displayed');
                },
                (progress) => {
                    if (progress.total > 0) {
                        const percent = (progress.loaded / progress.total * 100).toFixed(0);
                        infoEl.textContent = `Loading ${filename}... ${percent}%`;
                    }
                },
                (error) => {
                    console.error('‚ùå THREE.js JSON load error:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack,
                        filename: filename,
                        url: url
                    });
                    statusEl.textContent = '‚ùå Error';
                    statusEl.className = 'status-indicator error';
                    infoEl.textContent = `Error loading ${filename}: ${error.message || 'Unknown error'}`;
                    alert(`Failed to load THREE.js JSON file.\n\nError: ${error.message || 'Unknown error'}\n\nMake sure the file is a valid THREE.js JSON export.\n\nCheck browser console (F12) for details.`);
                }
            );
        }

        // Unified model loader
        function loadModel(url, filename) {
            const ext = filename.split('.').pop().toLowerCase();

            if (ext === 'stl') {
                loadSTL(url, filename);
            } else if (ext === 'glb' || ext === 'gltf') {
                loadGLTF(url, filename);
            } else if (ext === '3mf') {
                load3MF(url, filename);
            } else if (ext === 'json') {
                loadJSON(url, filename);
            } else {
                console.error('‚ùå Unsupported file format:', ext);
                alert(`Unsupported file format: .${ext}\nSupported: .stl, .glb, .gltf, .3mf, .json`);
            }
        }

        // Shared centering function
        function centerModel(model) {
            const originMode = document.getElementById('model-origin').value;

            // Calculate bounding box
            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);

            // Center based on selected mode
            if (originMode === 'center') {
                // Center to middle of mesh
                model.position.sub(center);
            } else if (originMode === 'bottom') {
                // Center X and Z, but align bottom to Y=0
                model.position.set(
                    -center.x,
                    -box.min.y,
                    -center.z
                );
            }

            return { box, center, size };
        }

        // Re-center currently loaded model
        window.recenterModel = function() {
            if (!meshGroup || meshGroup.children.length === 0) {
                alert('Please load a model first');
                return;
            }

            // Get the first child (the actual model)
            const model = meshGroup.children[0];
            if (!model) return;

            // Re-center
            const { size } = centerModel(model);

            // Recalculate camera position
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraDistance = Math.abs(maxDim / Math.sin(fov / 2));

            const distanceMultiplier = parseFloat(document.getElementById('camera-distance').value);
            cameraDistance *= distanceMultiplier;

            camera.position.set(
                cameraDistance * 0.5,
                cameraDistance * 0.5,
                cameraDistance
            );
            camera.lookAt(0, 0, 0);

            const originMode = document.getElementById('model-origin').value;
            const modeName = originMode === 'center' ? 'center' : 'bottom';
            console.log(`‚úÖ Model re-centered to ${modeName}`);
        };

        // Animation setup function
        function setupAnimations(gltf) {
            // Clear previous animations
            if (mixer) {
                mixer.stopAllAction();
                mixer = null;
            }
            currentAction = null;
            animations = gltf.animations || [];

            const animationSection = document.getElementById('animation-section');
            const animationClipSelect = document.getElementById('animation-clip');

            if (animations.length === 0) {
                // No animations, hide the section
                animationSection.style.display = 'none';
                animationClipSelect.innerHTML = '<option value="">No animations</option>';
                console.log('‚ÑπÔ∏è No animations found in GLTF');
                return;
            }

            // Show animation section
            animationSection.style.display = 'block';

            // Create animation mixer
            mixer = new THREE.AnimationMixer(gltf.scene);

            // Populate animation dropdown
            animationClipSelect.innerHTML = '<option value="">Select animation...</option>';
            animations.forEach((clip, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = clip.name || `Animation ${index + 1}`;
                animationClipSelect.appendChild(option);
            });

            console.log(`‚úÖ Found ${animations.length} animation(s):`, animations.map(a => a.name || 'Unnamed'));

            // Auto-play first animation if available
            if (animations.length > 0) {
                animationClipSelect.value = '0';
                playAnimation(0);
            }
        }

        // Play specific animation by index
        function playAnimation(index) {
            if (!mixer || !animations[index]) return;

            // Stop current action if exists
            if (currentAction) {
                currentAction.stop();
            }

            // Create and play new action
            const clip = animations[index];
            currentAction = mixer.clipAction(clip);

            // Apply settings
            const loop = document.getElementById('animation-loop').checked;
            const speed = parseFloat(document.getElementById('animation-speed').value);

            currentAction.loop = loop ? THREE.LoopRepeat : THREE.LoopOnce;
            currentAction.timeScale = speed;
            currentAction.play();

            console.log(`‚ñ∂Ô∏è Playing animation: ${clip.name || 'Unnamed'} (loop: ${loop}, speed: ${speed}x)`);
        }

        // Toggle animation play/pause
        window.toggleAnimation = function() {
            if (!currentAction) {
                alert('No animation loaded. Load a GLB/GLTF file with animations first.');
                return;
            }

            if (currentAction.paused) {
                currentAction.paused = false;
                console.log('‚ñ∂Ô∏è Animation resumed');
            } else {
                currentAction.paused = true;
                console.log('‚è∏Ô∏è Animation paused');
            }
        };

        // File input handler
        document.getElementById('file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Check for Alembic files (common mistake)
            if (file.name.toLowerCase().endsWith('.abc')) {
                alert('‚ö†Ô∏è Alembic (.abc) files are not supported.\n\nPlease convert to GLB/GLTF in Blender:\n1. Import .abc file\n2. Export as glTF 2.0 (.glb)');
                return;
            }

            // For GLB/GLTF files, check if they're valid
            if (file.name.toLowerCase().match(/\.(glb|gltf)$/)) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const arrayBuffer = event.target.result;
                    const bytes = new Uint8Array(arrayBuffer);

                    // Check for Alembic magic number "Ogawa"
                    const header = String.fromCharCode(...bytes.slice(0, 10));
                    if (header.includes('Ogawa') || header.includes('Alembic')) {
                        alert('‚ö†Ô∏è This file appears to be an Alembic cache file, not a GLB.\n\nThe file has a .glb extension but contains Alembic data.\n\nPlease re-export from Blender using the standard glTF 2.0 exporter:\n‚Ä¢ File ‚Üí Export ‚Üí glTF 2.0 (.glb)\n‚Ä¢ NOT a custom Alembic-based exporter');
                        statusEl.textContent = '‚ùå Error';
                        statusEl.className = 'status-indicator error';
                        infoEl.textContent = 'Invalid GLB: File contains Alembic data';
                        return;
                    }

                    // Check for valid GLB magic number (0x46546C67 = "glTF")
                    const magic = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
                    if (magic !== 0x46546C67) {
                        console.warn('‚ö†Ô∏è GLB magic number mismatch. Expected 0x46546C67, got:', magic.toString(16));
                        alert(`‚ö†Ô∏è This may not be a valid GLB file.\n\nFile format check failed.\n\nTry re-exporting from Blender using:\n‚Ä¢ File ‚Üí Export ‚Üí glTF 2.0 (.glb)\n‚Ä¢ Make sure to use the OFFICIAL Blender glTF exporter, not custom addons`);
                    }

                    // File seems valid or we'll try anyway, proceed with loading
                    const url = URL.createObjectURL(file);
                    loadModel(url, file.name);
                };

                // Read first 100 bytes to check format
                reader.readAsArrayBuffer(file.slice(0, 100));
            } else {
                // Non-GLB files, load directly
                const url = URL.createObjectURL(file);
                loadModel(url, file.name);
            }
        });

        // Sample loader
        window.loadSample = async function(filename) {
            const url = `test-assets/${filename}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('File not found');

                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);

                loadModel(objectUrl, filename);
            } catch (error) {
                console.error('‚ùå Failed to load sample:', error);
                statusEl.textContent = '‚ùå Error';
                statusEl.className = 'status-indicator error';
                infoEl.textContent = `Failed to load ${filename}. Make sure it exists in test-assets/`;
            }
        };

        // ========== VISUAL CONTROLS ==========

        // Helper function to apply material property to all meshes
        function applyToAllMeshes(callback) {
            if (meshGroup) {
                meshGroup.traverse((child) => {
                    if (child.isMesh && child.material) {
                        callback(child.material);
                    }
                });
            } else if (currentMaterial) {
                callback(currentMaterial);
            }
        }

        // Material Controls
        document.getElementById('material-color').addEventListener('input', (e) => {
            applyToAllMeshes((material) => {
                if (material.color) {
                    material.color.set(e.target.value);
                }
            });
        });

        document.getElementById('edge-color').addEventListener('input', (e) => {
            if (edgesMesh) {
                edgesMesh.material.color.set(e.target.value);
            }
        });

        document.getElementById('edge-thickness').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('edge-thickness-val').textContent = val;
            if (edgesMesh) {
                edgesMesh.material.linewidth = val;
            }
        });

        document.getElementById('metalness').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('metalness-val').textContent = val;
            applyToAllMeshes((material) => {
                if (material.metalness !== undefined) {
                    material.metalness = val;
                }
            });
        });

        document.getElementById('roughness').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('roughness-val').textContent = val;
            applyToAllMeshes((material) => {
                if (material.roughness !== undefined) {
                    material.roughness = val;
                }
            });
        });

        document.getElementById('show-edges').addEventListener('change', (e) => {
            if (edgesMesh) {
                edgesMesh.visible = e.target.checked;
            }
        });

        // Lighting Controls
        document.getElementById('hemi-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('hemi-intensity-val').textContent = val;
            hemiLight.intensity = val;
        });

        document.getElementById('key-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('key-intensity-val').textContent = val;
            keyLight.intensity = val;
        });

        document.getElementById('fill-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('fill-intensity-val').textContent = val;
            fillLight.intensity = val;
        });

        document.getElementById('rim-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('rim-intensity-val').textContent = val;
            rimLight.intensity = val;
        });

        document.getElementById('ambient-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('ambient-intensity-val').textContent = val;
            ambient.intensity = val;
        });

        document.getElementById('bg-mode').addEventListener('change', (e) => {
            const colorInput = document.getElementById('bg-color');
            if (e.target.value === 'transparent') {
                scene.background = null;
                colorInput.disabled = true;
            } else {
                scene.background = new THREE.Color(colorInput.value);
                colorInput.disabled = false;
            }
        });

        document.getElementById('bg-color').addEventListener('input', (e) => {
            if (document.getElementById('bg-mode').value === 'color') {
                scene.background.set(e.target.value);
            }
        });

        // Shader Preset System
        const shaderPresets = {
            pbr: { metalness: 0.3, roughness: 0.4, color: 0x888888, name: 'PBR Realistic' },
            toon: { metalness: 0.0, roughness: 1.0, color: 0xffffff, name: 'Toon/Cel Shaded' },
            matcap: { metalness: 0.0, roughness: 0.5, color: 0xcccccc, name: 'MatCap Style' },
            clay: { metalness: 0.0, roughness: 0.9, color: 0xe0e0e0, name: 'Clay Render' },
            metal: { metalness: 1.0, roughness: 0.2, color: 0xffffff, name: 'Metallic' },
            plastic: { metalness: 0.0, roughness: 0.3, color: 0xff6b35, name: 'Plastic' },
            glass: { metalness: 0.0, roughness: 0.05, color: 0xccffff, name: 'Glass' }
        };

        window.applyShaderPreset = function() {
            const presetName = document.getElementById('shader-preset').value;
            const preset = shaderPresets[presetName];

            if (!currentMaterial && !meshGroup) {
                alert('Please load a model first');
                return;
            }

            // Apply preset values to all materials
            applyToAllMeshes((material) => {
                if (material.metalness !== undefined) material.metalness = preset.metalness;
                if (material.roughness !== undefined) material.roughness = preset.roughness;
                if (material.color) material.color.setHex(preset.color);
            });

            // Update UI controls
            document.getElementById('metalness').value = preset.metalness;
            document.getElementById('metalness-val').textContent = preset.metalness;
            document.getElementById('roughness').value = preset.roughness;
            document.getElementById('roughness-val').textContent = preset.roughness;
            document.getElementById('material-color').value = '#' + preset.color.toString(16).padStart(6, '0');

            // Special handling for toon shader
            if (presetName === 'toon') {
                // Enable toon steps control
                document.getElementById('toon-steps').disabled = false;
                applyToonShader();
            } else {
                document.getElementById('toon-steps').disabled = true;
            }

            console.log('‚úÖ Applied shader preset:', preset.name);
        };

        function applyToonShader() {
            const steps = parseInt(document.getElementById('toon-steps').value);

            // Apply toon shader to all materials
            applyToAllMeshes((material) => {
                material.onBeforeCompile = (shader) => {
                    shader.fragmentShader = shader.fragmentShader.replace(
                        '#include <dithering_fragment>',
                        `
                        #include <dithering_fragment>

                        // Toon shading quantization
                        float toonSteps = ${steps}.0;
                        vec3 toonColor = floor(gl_FragColor.rgb * toonSteps) / toonSteps;
                        gl_FragColor.rgb = toonColor;
                        `
                    );
                };
                material.needsUpdate = true;
            });
        }

        document.getElementById('shader-preset').addEventListener('change', () => {
            const preset = document.getElementById('shader-preset').value;
            document.getElementById('toon-steps').disabled = (preset !== 'toon');
        });

        document.getElementById('toon-steps').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('toon-steps-val').textContent = val;
            if (document.getElementById('shader-preset').value === 'toon' && currentMaterial) {
                applyToonShader();
            }
        });

        // Environment Map Presets
        const envPresets = {
            studio: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/studio_small_08.jpg',
            outdoor: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/kloppenheim_02.jpg',
            sunset: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/sunset_jhbcentral.jpg',
            night: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/tokyo_bigsight.jpg',
            warehouse: 'https://dl.polyhaven.org/file/ph-assets/HDRIs/extra/Tonemapped%20JPG/warehouse.jpg'
        };

        document.getElementById('env-preset').addEventListener('change', (e) => {
            const presetName = e.target.value;
            const urlInput = document.getElementById('env-map-url');

            if (presetName && envPresets[presetName]) {
                urlInput.value = envPresets[presetName];
                urlInput.disabled = true;
            } else {
                urlInput.disabled = false;
            }
        });

        // Environment Map Loader
        window.loadEnvironmentMap = function() {
            const url = document.getElementById('env-map-url').value.trim();
            if (!url) {
                alert('Please enter an environment map URL');
                return;
            }

            console.log('üåç Loading environment map:', url);
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(
                url,
                (texture) => {
                    console.log('‚úÖ Environment map loaded');

                    // Create equirectangular environment map
                    const pmremGenerator = new THREE.PMREMGenerator(renderer);
                    pmremGenerator.compileEquirectangularShader();

                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    scene.environment = envMap;

                    texture.dispose();
                    pmremGenerator.dispose();

                    // Apply environment map intensity to all materials
                    const intensity = parseFloat(document.getElementById('env-intensity').value);
                    applyToAllMeshes((material) => {
                        if (material.envMapIntensity !== undefined) {
                            material.envMapIntensity = intensity;
                            material.needsUpdate = true;
                        }
                    });

                    alert('Environment map loaded successfully!');
                },
                undefined,
                (error) => {
                    console.error('‚ùå Environment map load error:', error);
                    alert('Failed to load environment map. Check the URL and CORS settings.');
                }
            );
        };

        document.getElementById('env-intensity').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('env-intensity-val').textContent = val;
            applyToAllMeshes((material) => {
                if (material.envMapIntensity !== undefined) {
                    material.envMapIntensity = val;
                }
            });
        });

        // Camera Controls
        document.getElementById('camera-distance').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('camera-distance-val').textContent = val;
            // Note: Camera distance is applied when loading a new model
        });

        document.getElementById('fov').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('fov-val').textContent = val;
            camera.fov = val;
            camera.updateProjectionMatrix();
        });

        document.getElementById('rotate-speed').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('rotate-speed-val').textContent = val;
            rotateSpeed = val;
        });

        // Animation Controls
        document.getElementById('animation-clip').addEventListener('change', (e) => {
            const index = parseInt(e.target.value);
            if (!isNaN(index) && index >= 0) {
                playAnimation(index);
            }
        });

        document.getElementById('animation-loop').addEventListener('change', (e) => {
            if (currentAction) {
                currentAction.loop = e.target.checked ? THREE.LoopRepeat : THREE.LoopOnce;
                console.log(`üîÅ Loop ${e.target.checked ? 'enabled' : 'disabled'}`);
            }
        });

        document.getElementById('animation-speed').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('animation-speed-val').textContent = val;
            if (currentAction) {
                currentAction.timeScale = val;
                console.log(`‚ö° Animation speed: ${val}x`);
            }
        });

        // ========== UI CONTROLS ==========

        // Toggle panel visibility
        window.togglePanel = function() {
            const panel = document.getElementById('controls-panel');
            panel.classList.toggle('collapsed');
        };

        console.log('‚úÖ Page ready');
    </script>
</body>
</html>
